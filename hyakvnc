#! /usr/bin/env bash
# hyakvnc - A script to launch VNC sessions on Hyak
HYAKVNC_VERSION="0.3.1"

# Check Bash version greater than 4.4:
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]] || [[ "${BASH_VERSINFO[0]:-0}" -eq 4 && "${BASH_VERSINFO[1]:-0}" -lt 4 ]]; then { echo >&2 "Requires Bash version > 4.x"; exit 1; }; fi

# Only enable these shell behaviours if we're not being sourced
if ! (return 0 2>/dev/null); then
	[[ "${XDEBUG:-0}" =~ ^[1yYtT] ]] && set -x
	set -o pipefail           # Use last non-zero exit code in a pipeline
	set -o errtrace           # Ensure the error trap handler is inherited
	shopt -qs lastpipe        # Run the last command in a pipeline in the current shell
	shopt -qs inherit_errexit # Ensure subshells exit on error
fi

# ## App preferences:
HYAKVNC_DIR="${HYAKVNC_DIR:-${HOME}/.hyakvnc}"                     # %% Local directory to store application data (default: `$HOME/.hyakvnc`)
HYAKVNC_CONFIG_FILE="${HYAKVNC_DIR}/hyakvnc-config.env"            # %% Configuration file to use (default: `$HYAKVNC_DIR/hyakvnc-config.env`)
HYAKVNC_LOG_FILE="${HYAKVNC_LOG_FILE:-${HYAKVNC_DIR}/hyakvnc.log}" # %% Log file to use (default: `$HYAKVNC_DIR/hyakvnc.log`)
HYAKVNC_LOG_LEVEL="${HYAKVNC_LOG_LEVEL:-INFO}"                     # %% Log level to use for interactive output (default: `INFO`)
HYAKVNC_LOG_FILE_LEVEL="${HYAKVNC_LOG_FILE_LEVEL:-DEBUG}"          # %% Log level to use for log file output (default: `DEBUG`)

# ## Logging functions:

# Create associative arrays for log levels and colors:
declare -A Log_Levels=([OFF]=0 [FATAL]=1 [ERROR]=2 [WARN]=3 [INFO]=4 [DEBUG]=5 [TRACE]=6 [ALL]=100)
declare -A Log_Level_Colors=([FATAL]=5 [ERROR]=1 [WARN]=3 [INFO]=4 [DEBUG]=6 [TRACE]=2)

# check_log_level()
# Check if the current log level is high enough to log a message
# Arguments: <level>
function check_log_level() {
	local loglevel refloglevel
	local -i loglevelno refloglevelno
	loglevel="${1:-INFO}"
	refloglevel="${HYAKVNC_LOG_LEVEL:-INFO}"

	[[ -z "${loglevelno:=${Log_Levels[${loglevel}]:-}}" ]] && return 1
	[[ -z "${refloglevelno:=${Log_Levels[${refloglevel}]:-}}" ]] && return 1
	((levelno >= refloglevelno))
}

# log()
# Log a message to the stderr and the log file if the log level is high enough
# Arguments: <level> <message>
# 	<level> is the log level, e.g. INFO, WARN, ERROR, etc. (default: INFO)
#	<message> is the message to log (default: empty string)
#
# Environment variables:
#	$HYAKVNC_LOG_LEVEL - The log level to use for interactive output (default: INFO)
#	$HYAKVNC_LOG_FILE - The log file to use (default: $HYAKVNC_DIR/hyakvnc.log)
#  	$HYAKVNC_LOG_FILE_LEVEL - The log level to use for log file output (default: DEBUG)
function log() {
	[[ "${_HYAKVNC_LOG_NOTRACE:=1}" == 1 ]] && [[ $- == *x* ]] && set +x && _HYAKVNC_LOG_NOTRACE=x # If we're in a shell with xtrace enabled, disable xtrace while logging
	(($# < 1)) && { echo >&2 "ERROR in log(): No arguments provided"; [[ "${_HYAKVNC_LOG_NOTRACE:-}" == "x" ]] && _HYAKVNC_LOG_NOTRACE=1 && set -x; return 1; }
	local level levelno curlevelno curlogfilelevelno curloglevel curlogfilelevel
	level="${1:-}"
	shift
	[[ -z "${levelno:=${Log_Levels[${level}]}}" ]] && { echo >&2 "ERROR in log(): Unknown log level: ${level}"; [[ "${_HYAKVNC_LOG_NOTRACE:-}" == "x" ]] && _HYAKVNC_LOG_NOTRACE=1 && set -x; return 0; }
	curloglevel="${HYAKVNC_LOG_LEVEL:-INFO}"
	[[ -z "${curlevelno:=${Log_Levels[${curloglevel}]}}" ]] && { echo >&2 "ERROR in log(): Unknown interactive log level: ${curloglevel}"; [[ "${_HYAKVNC_LOG_NOTRACE:-}" == "x" ]] && _HYAKVNC_LOG_NOTRACE=1 && set -x; return 0; }
	[[ "${HYAKVNC_LOG_FILE:-/dev/null}" == "/dev/null" ]] && curlogfilelevel="OFF" || curlogfilelevel="${HYAKVNC_LOG_FILE_LEVEL:-DEBUG}"
	[[ -z "${curlogfilelevelno:=${Log_Levels[${curlogfilelevel}]}}" ]] && { echo >&2 "ERROR in log(): Unknown logfile log level: ${curloglevel}"; [[ "${_HYAKVNC_LOG_NOTRACE:-}" == "x" ]] && _HYAKVNC_LOG_NOTRACE=1 && set -x; return 0; }

	local logctx curlogctx sourcefile lineno funcname
	sourcefile="${BASH_SOURCE[1]:-}"
	sourcefile="${sourcefile##*/}" # Remove everything before the last slash
	lineno="${BASH_LINENO[1]:-}"
	[[ -n "${funcname:=${FUNCNAME[1]:-}}" ]] && funcname="${funcname}()" # Add parentheses to function name
	logctx=" @ ${sourcefile:+${sourcefile}${lineno:+:}}${lineno:+${lineno}${funcname:+:}}${funcname:+${funcname}}"
	if ((curlevelno >= levelno)); then
		((curlevelno >= "${Log_Levels[DEBUG]}")) && curlogctx="${logctx}"
		[[ -t 1 ]] && tput setaf "${Log_Level_Colors[${level}]:-}" 2>/dev/null # If we're in a terminal, use colors
		printf >&2 '%s%s:' "${level}" "${curlogctx:-}"
		[[ -t 1 ]] && tput sgr0 2>/dev/null # If we're in a terminal, unset colors
		printf >&2 ' %b\n' "${*:-}"
	fi

	if ((curlogfilelevelno >= levelno)); then
		((curlogfilelevelno >= "${Log_Levels[DEBUG]}")) && curlogctx="${logctx}"
		printf >&2 '%s %s%s: %b\n' "$(date -Is || printf '' || true)" "${level}" "${curlogctx:-}" "${*:-}" >>"${HYAKVNC_LOG_FILE:-/dev/null}"
	fi
	[[ "${_HYAKVNC_LOG_NOTRACE:-}" == "x" ]] && _HYAKVNC_LOG_NOTRACE=1 && set -x;
	return 0
}

# ## General utility functions:

# check_command()
# Check if a command is available
# Arguments:
# - <command> - The command to check
# - <loglevel> <message> - Passed to log if the command is not available (optional)
function check_command() {
	if [[ -z "${1:-}" ]] || ! command -v "${1}" >/dev/null 2>&1; then
		[[ $# -gt 1 ]] && log "${@:2}"
		return 1
	fi
	return 0
}

# hyakvnc_load_config()
# Load the hyakvnc configuration from the config file
# This is high up in the file so that settings can be overridden by the user's config
# Arguments: None
function hyakvnc_load_config() {
	[[ -r "${HYAKVNC_CONFIG_FILE:-}" ]] || return 0 # Return if config file doesn't exist

	# Read each line of the parsed config file and export the variable:
	while IFS=$'\n' read -r line; do
		# Get the variable name by removing everything after the equals sign. Uses nameref to allow indirect assignment (see https://gnu.org/software/bash/manual/html_node/Shell-Parameters.html):
		declare -n varref="${line%%=*}"
		# Evaluate the right-hand side of the equals sign:
		varref="$(bash --restricted --posix -c "echo ${line#*=}" || true)"
		# Export the variable:
		export "${!varref}"
		# If DEBUG is not 0, print the variable:
		[[ "${DEBUG:-0}" != 0 ]] && echo "Loaded variable from \"CONFIG_FILE\": ${!varref}=(${varref})" >&2
	done < <(sed -E 's/^\s*//;  /^[^#=]+=.*/!d;  s/^([^=\s]+)\s+=/\1=/;' "${HYAKVNC_CONFIG_FILE}" || true) # Parse config file, ignoring comments and blank lines, removing leading whitespace, and removing whitespace before (but not after) the equals sign
}

# Load config if not sourced:
if ! (return 0 2>/dev/null); then
	hyakvnc_load_config
fi

if sacctmgr show cluster -o --noheader --associations --parsable2 format=Cluster 2>/dev/null | grep -q '^klone$'; then
	HYAKVNC_BACKEND="slurm"
	HYAKVNC_SSH_HOST="klone.hyak.uw.edu"
	SBATCH_CLUSTERS="klone"
elif command -v apptainer >/dev/null 2>&1; then
	HYAKVNC_BACKEND="apptainer"
else
	log "No backend found. Please run on the UW klone cluster or install apptainer."
	exit 1
fi

HYAKVNC_BACKEND="${HYAKVNC_BACKEND:-apptainer}"                                   # %% Backend to use (default: (`klone` if running on Hyak Klone cluster, `apptainer` otherwise))
HYAKVNC_JOB_PREFIX="${HYAKVNC_JOB_PREFIX:-hyakvnc-}"                              # %% Prefix to use for hyakvnc job names (default: `hyakvnc-`)
HYAKVNC_JOBS_DIR="${HYAKVNC_JOBS_DIR:-${HYAKVNC_DIR}/${jobs}/${HYAKVNC_BACKEND}}" # %% Directory to store job data (default: `$HYAKVNC_DIR/jobs`)
HYAKVNC_REPO_DIR="${HYAKVNC_REPO_DIR:-${HYAKVNC_DIR}/hyakvnc}"                    # Local directory to store git repository (default: `$HYAKVNC_DIR/hyakvnc`)
HYAKVNC_CHECK_UPDATE_FREQUENCY="${HYAKVNC_CHECK_UPDATE_FREQUENCY:-0}"             # %% How often to check for updates in `[d]`ays or `[m]`inutes (default: `0` for every time. Use `1d` for daily, `10m` for every 10 minutes, etc. `-1` to disable.)
HYAKVNC_DEFAULT_TIMEOUT="${HYAKVNC_DEFAULT_TIMEOUT:-30}"                          # %% Seconds to wait for most commands to complete before timing out (default: `30`)

HYAKVNC_SSH_HOST="${HYAKVNC_SSH_HOST:-localhost}" # %% Default SSH host to use for connection strings (default: `localhost` if backend is apptainer or docker, `klone.hyak.uw.edu` if backend is `klone`)

# ## VNC preferences:
HYAKVNC_VNC_PASSWORD="${HYAKVNC_VNC_PASSWORD:-password}" # %% Password to use for new VNC sessions (default: `password`)
HYAKVNC_VNC_DISPLAY="${HYAKVNC_VNC_DISPLAY:-:10}"        # %% VNC display to use (default: `:1`)

HYAKVNC_MACOS_VNC_VIEWER_BUNDLEIDS="${HYAKVNC_MACOS_VNC_VIEWER_BUNDLEIDS:-com.turbovnc.vncviewer.VncViewer com.turbovnc.vncviewer}" # macOS bundle identifiers for VNC viewer executables (default: `com.turbovnc.vncviewer com.realvnc.vncviewer com.tigervnc.vncviewer`)

# ## Apptainer preferences:
HYAKVNC_APPTAINER_CONTAINERS_DIR="${HYAKVNC_APPTAINER_CONTAINERS_DIR:-}" # %% Directory to look for apptainer containers (default: (none))

APPTAINER_WRITABLE_TMPFS="${APPTAINER_WRITABLE_TMPFS:-1}" # %% Whether to mount a writable tmpfs at /tmp (default: `1`)
APPTAINER_CONTAIN="${APPTAINER_CONTAIN:-1}"               # %% Whether to run the container in a separate process (default: `1`)
# ## Slurm preferences:

if [[ "${HYAKVNC_BACKEND}" == "slurm" ]]; then
	HYAKVNC_SLURM_SUBMIT_TIMEOUT="${HYAKVNC_SLURM_SUBMIT_TIMEOUT:-120}"                 # %% Seconds after submitting job to wait for the job to start before timing out (default: `120`)
	HYAKVNC_SLURM_OUTPUT_DIR="${SBATCH_OUTPUT:-${HYAKVNC_DIR}/jobs/slurm/slurm-output}" # %% Directory to store SLURM output files (default: `$HYAKVNC_DIR/slurm/slurm-output`)
	SBATCH_OUTPUT="${SBATCH_OUTPUT:-${HYAKVNC_SLURM_OUTPUT_DIR}/%j.out}}"               # %% Where to send SLURM job output (default: `$HYAKVNC_SLURM_OUTPUT_DIR/%j.out`)
	if [[ "${SBATCH_CLUSTERS:-}" == "klone" ]]; then
		if [[ -z "${APPTAINER_CACHEDIR:-}" ]] && [[ -d "/gscratch/scrubbed" ]]; then
			APPTAINER_CACHEDIR="/gscratch/scrubbed/${USER}/cache/apptainer"
			mkdir -p "${APPTAINER_CACHEDIR}" || { log ERROR "Failed to create APPTAINER_CACHEDIR \"${APPTAINER_CACHEDIR}"\"; exit 1; }
		fi
		SRUN_CPUS_PER_TASK="${SRUN_CPUS_PER_TASK:-1}" # %% Number of CPUs to request per task (default: `1`)
		SBATCH_MEM="${SBATCH_MEM:-4G}"                # %% Amount of memory to request (default: (4G))
		SBATCH_TIME="${SBATCH_TIME:-4:00:00}"         # %% Amount of time to request (default: (4:00:00))
	fi
	mkdir -p "${HYAKVNC_SLURM_OUTPUT_DIR}" || { log ERROR "Failed to create HYAKVNC_SLURM_OUTPUT_DIR \"${HYAKVNC_SLURM_OUTPUT_DIR}\""; exit 1; }
fi

# ## Update functions:

# hyakvnc_pull_updates()
# Pull updates from the hyakvnc git repository
# Arguments: None
# Returns: 0 if successfuly updated, 1 if not or if an error occurred
function hyakvnc_pull_updates() {
	local cur_branch
	[[ -z "${HYAKVNC_REPO_DIR:-}" ]] && {
		log ERROR "HYAKVNC_REPO_DIR is not set. Can't pull updates."
		return 1
	}
	cur_branch="$(git -C "${HYAKVNC_REPO_DIR}" branch --show-current 2>&1 || true)"
	[[ -z "${cur_branch}" ]] && {
		log ERROR "Couldn't determine current branch. Can't pull updates."
		return 1
	}

	[[ "${cur_branch}" != "main" ]] && {
		log WARN "Current branch is ${cur_branch}, not main. Be warned that this branch may not be up to date."
	}

	log INFO "Updating hyakvnc..."
	git -C "${HYAKVNC_REPO_DIR}" pull --quiet origin "${cur_branch}" || {
		log WARN "Couldn't apply updates"
		return 0
	}

	log INFO "Successfully updated hyakvnc."
	return 0
}

# hyakvnc_check_updates()
# Check if a hyakvnc update is available
# Arguments: None
# Returns: 0 if an update is available, 1 if none or if an error occurred
function hyakvnc_check_updates() {
	log DEBUG "Checking for updates... "
	# Check if git is installed:
	check_command git ERROR || return 1

	# Check if git is available and that the git directory is a valid git repository:
	git -C "${HYAKVNC_REPO_DIR}" tag >/dev/null 2>&1 || {
		log DEBUG "Configured git directory ${HYAKVNC_REPO_DIR} doesn't seem to be a valid git repository. Can't check for updates"
		return 1
	}

	local cur_branch
	cur_branch="$(git -C "${HYAKVNC_REPO_DIR}" branch --show-current 2>&1 || true)"
	[[ -z "${cur_branch}" ]] && {
		log ERROR "Couldn't determine current branch. Can't pull updates."
		return 1
	}

	[[ "${cur_branch}" != "main" ]] && {
		log WARN "Current branch is ${cur_branch}, not main. Be warned that this branch may not be up to date."
	}

	local cur_date
	cur_date="$(git -C "${HYAKVNC_REPO_DIR}" show -s --format=%cd --date=human-local "${cur_branch}" || echo ???)"
	log INFO "The installed version was published ${cur_date}"

	touch "${HYAKVNC_REPO_DIR}/.last_update_check"

	# Get hash of local HEAD:
	if [[ "$(git -C "${HYAKVNC_REPO_DIR}" rev-parse "${cur_branch}" || true)" == "$(git -C "${HYAKVNC_REPO_DIR}" ls-remote --heads --refs origin "${cur_branch}" | cut -f1 || true)" ]]; then
		log INFO "hyakvnc is up to date."
		return 1
	fi

	git -C "${HYAKVNC_REPO_DIR}" fetch --quiet origin "${cur_branch}" || {
		log DEBUG "Failed to fetch from remote"
		return 1
	}

	local nchanges
	nchanges="$(git -C "${HYAKVNC_REPO_DIR}" rev-list HEAD...origin/"${cur_branch}" --count || echo 0)"
	if [[ "${nchanges}" -gt 0 ]]; then
		local new_date
		new_date="$(git -C "${HYAKVNC_REPO_DIR}" show -s --format=%cd --date=human-local origin/"${cur_branch}" || echo ???)"
		log INFO "Found ${nchanges} updates. Most recent: ${new_date}"
		return 0
	fi
	return 1
}

# hyakvnc_autoupdate()
# Unless updates were checked recenetly per $HYAKVNC_CHECK_UPDATE_FREQUENCY,
# 	check if a hyakvnc update is available. If running interactively, prompt
#	to apply update (or disable prompt in the future). If not running interactively,
#	apply the update.
# Arguments: None
# Returns: 0 if an update is available and the user wants to update, 1 if none or if an error occurred
function hyakvnc_autoupdate() {
	if [[ "${HYAKVNC_CHECK_UPDATE_FREQUENCY:-0}" == "-1" ]]; then
		log DEBUG "Skipping update check"
		return 1
	fi

	if [[ "${HYAKVNC_CHECK_UPDATE_FREQUENCY:-0}" != "0" ]]; then
		local update_frequency_unit="${HYAKVNC_CHECK_UPDATE_FREQUENCY:0-1}"
		local update_frequency_value="${HYAKVNC_CHECK_UPDATE_FREQUENCY:0:-1}"
		local find_m_arg=()

		case "${update_frequency_unit:=d}" in
			d)
				find_m_arg+=(-mtime "+${update_frequency_value:=0}")
				;;
			m)
				find_m_arg+=(-mmin "+${update_frequency_value:=0}")
				;;
			*)
				log ERROR "Invalid update frequency unit: ${update_frequency_unit}. Please use [d]ays or [m]inutes."
				return 1
				;;
		esac

		log DEBUG "Checking if ${HYAKVNC_REPO_DIR}/.last_update_check is older than ${update_frequency_value}${update_frequency_unit}..."

		if [[ -r "${HYAKVNC_REPO_DIR}/.last_update_check" ]] && [[ -z $(find "${HYAKVNC_REPO_DIR}/.last_update_check" -type f "${find_m_arg[@]}" -print || true) ]]; then
			log DEBUG "Skipping update check because the last check was less than ${update_frequency_value}${update_frequency_unit} ago."
			return 1
		fi

		log DEBUG "Checking for updates because the last check was more than ${update_frequency_value}${update_frequency_unit} ago."
	fi

	hyakvnc_check_updates || { log DEBUG "No updates found."; return 1; }

	if [[ -t 1 ]]; then # Check if we're running interactively
		while true; do     # Ask user if they want to update
			local choice
			read -r -p "Would you like to update hyakvnc? [y/n] [x to disable]: " choice
			case "${choice}" in
				y | Y | yes | Yes)
					log INFO "Updating hyakvnc..."
					hyakvnc_pull_updates || {
						log WARN "Didn't update hyakvnc"
						return 1
					}
					log INFO "Successfully updated hyakvnc. Restarting..."
					echo
					exec "${0}" "${@}" # Restart hyakvnc
					;;
				n | N | no | No)
					log INFO "Not updating hyakvnc"
					return 1
					;;
				x | X)
					log INFO "Disabling update checks"
					export HYAKVNC_CHECK_UPDATE_FREQUENCY="-1"
					if [[ -n "${HYAKVNC_CONFIG_FILE:-}" ]]; then
						touch "${HYAKVNC_CONFIG_FILE}" && echo 'HYAKVNC_CHECK_UPDATE_FREQUENCY=-1' >>"${HYAKVNC_CONFIG_FILE}"
						log INFO "Set HYAKVNC_CHECK_UPDATE_FREQUENCY=-1 in ${HYAKVNC_CONFIG_FILE}"
					fi
					return 1
					;;
				*)
					echo "Please enter y, n, or x"
					;;
			esac
		done
	else
		hyakvnc_pull_updates || { log INFO "Didn't update hyakvnc"; return 1; }
	fi
	return 0
}


# relativize_date()
# Convert a date to a relative date
# Arguments: <date>
# Stdout: Relative date
function relativize_date() {
	local date_a date_base
	local -i diff_seconds days hours minutes seconds
	(( $# < 1)) || (( $# > 2 )) && return 1
	(( $# == 1)) && date_base="$(date '+%s')" || return 1
	(( $# == 2 )) && date_base="$(date -d "$2" '+%s')" 
	date_a="$(date -d "$1" '+%s')" || return 1
	# Calculate the difference in seconds
	diff_seconds=$((date_a - date_base))
	# Convert the difference to relative time duration
	days=$((diff_seconds / 86400))
	hours=$(( (diff_seconds % 86400) / 3600))
	minutes=$(( ((diff_seconds % 86400) % 3600) / 60))
	seconds=$(( ((diff_seconds % 86400) % 3600) % 60))

	if ((days != 0)); then
		printf '%dd %dh %dm %ds' "${days#-}" "${hours#-}" "${minutes#-}" "${seconds#-}"
	elif ((hours != 0)); then
		printf '%dh %dm %ds' "${hours#-}" "${minutes#-}" "${seconds#-}"
	elif ((minutes != 0)); then
		printf '%dm %ds' "${minutes#-}" "${seconds#-}"
	elif ((seconds != 0)); then
		printf '%ds' "${seconds#-}"
	fi
	if (( diff_seconds < 0 )); then
		printf ' ago'
	else
		printf ' from now'
	fi
	printf '\n'
	return 0
}
 
# ## SLURM utility functons:

# check_slurm_running {
# Check if SLURM is running
# Arguments: None
function check_slurm_running() {
	sinfo >/dev/null 2>&1 || return 1
}

# expand_slurm_node_range()
# Expand a SLURM node range to a list of nodes
# Arguments: <node range>
function expand_slurm_node_range() {
	[[ -z "${1:-}" ]] && return 1
	result=$(scontrol show hostnames --oneliner "${1}" | grep -oE '^.+$' | tr ' ' '\n') || return 1
	echo "${result}" && return 0
}

# slurm_list_partitions()
# List SLURM partitions
#
# Arguments:
# 	--cluster <name>: Cluster to list partitions for
#	--user <name>: User to list partitions for
#	--account <name>: Account to list partitions for
#	--max_count <n>: Maximum number of partitions to list
#
# stdout: List of partitions
# Returns: 0 if successful, 1 otherwise
function slurm_list_partitions() {
	check_command sacctmgr ERROR || return 1
	local cluster account partitions max_count user

	while true; do
		case "${1:-}" in
			--cluster)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				cluster="$1" ;;
			--user)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				user="$1" ;;
			--account)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				account="$1" ;;
			--max-count)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				max_count="$1" ;;
			*) break ;;
		esac
		shift
	done

	[[ -z "${user:=${USER:-}}" ]] && { log ERROR "No user specified"; return 1; }

	local sacctmgr_args=(show --noheader --parsable2 --associations user "${user:-}" format=qos)

	# Add filters if specified:
	[[ -n "${account:-}" ]] && sacctmgr_args+=(where "account=${account}")
	[[ -n "${cluster:-}" ]] && sacctmgr_args+=("cluster=${cluster}")

	# Get partitions:
	partitions="$(sacctmgr "${sacctmgr_args[@]}" | tr ',' '\n')" || { log ERROR "sacctmgr failed with code $?"; return 1; }

	# If running on klone, process the partition names as required (see hyakalloc):
	if [[ "${cluster:-}" == "klone" ]] && [[ -n "${partitions:-}" ]]; then
		partitions="$(echo "${partitions:-}" | klone_read_qos)" || { log ERROR "Failed to process partition names"; return 1; }
	fi

	# Filter out duplicates and sort:
	partitions="$(echo "${partitions:-}" | sort | uniq | head -n "${max_count:-0}")" || { log ERROR "Failed to sort partitions"; return 1; }

	# Check if we got any partitions:
	[[ -n "${partitions:-}" ]] || { log ERROR "No partitions found"; return 1; }

	# Return the partitions:
	echo "${partitions}"
	return 0
}

# klone_read_qos()
# Return the correct QOS on Hyak for the given partition on hyak
# Logic copied from hyakalloc's hyakqos.py:QosResource.__init__():
# Arguments: <partition> (optional, read from stdin if not provided)
# stdout: QOS
# shellcheck disable=SC2120
function klone_read_qos() {
	local qos_name="${1:-$(</dev/stdin)}" # Read from stdin if no argument is provided
	[[ -z "${qos_name:-}" ]] && return 1
	if [[ "${qos_name}" == *-* ]]; then
		qos_suffix="${qos_name#*-}" # Extract portion after the first "-"
		if [[ "${qos_suffix}" == *mem ]]; then
			echo "compute-${qos_suffix}"
		else
			echo "${qos_suffix}"
		fi
	else
		echo "compute"
	fi
}

# slurm_list_clusters()
# List SLURM clusters
#
# Arguments:
# 	--max_count <n>  Maximum number of clusters to list (optional)
# stdout: List of clusters
function slurm_list_clusters() {
	check_command sacctmgr ERROR || return 1
	local clusters max_count
	local sacctmgr_args=(show cluster --noheader --parsable2 --associations format=Cluster)

	while true; do
		case "${1:-}" in
			--max-count)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				max_count="$1" ;;
			*) break ;;
		esac
		shift
	done

	clusters="$(sacctmgr "${sacctmgr_args[@]}" | tr ',' '\n' | sort | uniq | head -n "${max_count:-0}")" || { log ERROR "sacctmgr failed to list clusters with code $?"; return 1; }
	[[ -n "${clusters:-}" ]] || { log ERROR "No clusters found"; return 1; }
	echo "${clusters:-}"
	return 0
}

# slurm_get_default_account()
# Get the default SLURM account
#
# Arguments:
# 	--cluster <name>: Cluster to get the default account for
#	--user <name>: User to get the default account for (default: $USER)
# stdout: Default account
# Returns: 0 if successful, 1 otherwise
function slurm_get_default_account() {
	check_command sacctmgr ERROR || return 1
	local user
	local default_account
	local sacctmgr_args=(--noheader --parsable2 --associations format=defaultaccount)

	while true; do
		case "${1:-}" in
			--cluster)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				sacctmgr_args+=("cluster=$1") ;;
			--user)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				user="$1" ;;
			*) break ;;
		esac
		shift
	done

	[[ -z "${user:=${USER:-}}" ]] && { log ERROR "No user specified"; return 1; }
	default_account="$(sacctmgr show user "${user}" "${sacctmgr_args[@]}" | tr ',' '\n' | sort | uniq | head -n 1)" || { log ERROR "sacctmgr failed with code $?"; return 1; }
	[[ -n "${default_account:-}" ]] || { log ERROR "No default account found"; return 1; }
	echo "${default_account}"
	return 0
}

# hyakvnc_config_init()
# Initialize the hyakvnc configuration
# Arguments: None
function hyakvnc_config_init() {
	[[ -z "${HYAKVNC_JOBS_DIR:-}" ]] && { log ERROR "\$HYAKVNC_JOBS_DIR is not set. Can't initialize configuration."; return 1; }
	mkdir -p "${HYAKVNC_JOBS_DIR}" || { log ERROR "Failed to create \$HYAKVMC_JOBS_DIR \"${HYAKVMC_JOBS_DIR:-}\""; return 1; }

	case "${HYAKVNC_BACKEND:-}" in
		slurm)
			check_command squeue || return 1
			mkdir -p "${HYAKVNC_SLURM_OUTPUT_DIR}" || {
				log ERROR "Failed to create HYAKVNC jobs directory ${HYAKVNC_DIR}/jobs"
				return 1
			}

			if [[ -z "${SBATCH_CLUSTERS:-}" ]]; then
				SBATCH_CLUSTERS=$(slurm_list_clusters --max-count 1) || { log ERROR "Failed to get SLURM clusters"; unset SBATCH_CLUSTERS; }
			fi

			if [[ -z "${SBATCH_ACCOUNT}" ]]; then
				SBATCH_ACCOUNT="$(slurm_get_default_account --user "${USER}" --cluster "${SBATCH_CLUSTERS}")" || { log ERROR "Failed to get default SLURM account"; unset SBATCH_ACCOUNT; }
			fi

			if [[ -z "${SBATCH_PARTITION:-}" ]]; then
				SBATCH_PARTITION=$(slurm_list_partitions --user "${USER}" --account "${SBATCH_ACCOUNT}" --cluster "${SBATCH_CLUSTERS}" --max-count 1) || { log ERROR "Failed to get SLURM partitions"; unset SBATCH_PARTITION; }
			fi

			;;

		apptainer) ;;

		*)
			log ERROR "Unknown \$HYAKVNC_BACKEND: \"${HYAKVNC_BACKEND:-}\""
			return 1
			;;
	esac

	# Export relevant variables:
	[[ -n "${!APPTAINER_@}" ]] && export "${!APPTAINER_@}"           # Export all SBATCH_ variables
	[[ -n "${!APPTAINERENV_@}" ]] && export "${!APPTAINERENV_@}"     # Export all SBATCH_ variables
	[[ -n "${!SINGULARITY_@}" ]] && export "${!SINGULARITY_@}"       # Export all SBATCH_ variables
	[[ -n "${!SINGULARITYENV_@}" ]] && export "${!SINGULARITYENV_@}" # Export all SBATCH_ variables
	[[ -n "${!HYAKVNC_@}" ]] && export "${!HYAKVNC_@}"               # Export all SBATCH_ variables
}

# stop_hyakvnc_session()
# Stop a Hyak VNC session, given a job ID
# Arguments: <jobid> [ -c | --cancel ] [ --no-rm ]
function stop_hyakvnc_session() {
	local jobid should_cancel no_rm
	while true; do
		case ${1:-} in
			-c | --cancel)
				shift
				should_cancel=1
				;;
			--no-rm) # Don't remove the job directory
				shift
				no_rm=1
				;;
			*)
				jobid="${1:-}"
				break
				;;
		esac
	done

	[[ -z "${jobid}" ]] && {
		log ERROR "Job ID must be specified"
		return 1
	}
	log DEBUG "Stopping VNC session for job ${jobid}"
	local jobdir pid tmpdirname
	jobdir="${HYAKVNC_DIR}/jobs/${jobid}"
	if [[ -d "${HYAKVNC_JOB_DIR}" ]]; then
		local pidfile
		for pidfile in "${HYAKVNC_JOB_DIR}/vnc/"*"${HYAKVNC_VNC_DISPLAY}".pid; do
			if [[ -r "${pidfile:-}" ]]; then
				read -r pid <"${pidfile}"
				[[ -z "${pid:-}" ]] && {
					log WARN "Failed to get pid from ${pidfile}"
					break
				}
				srun --jobid "${jobid}" kill "${pid}" || log WARN "srun failed to stop VNC process for job ${jobid} with pid ${pid}"
				break
			fi
		done
		if [[ -r "${HYAKVNC_JOB_DIR}/tmpdirname" ]]; then
			read -r tmpdirname <"${pidfile}"
			[[ -z "${tmpdirname}" ]] && log WARN "Failed to get tmpdirname from ${HYAKVNC_JOB_DIR}/tmpdirname"
			srun --quiet --jobid "${jobid}" rm -rf "${tmpdirname}" || log WARN "Failed to remove container /tmp directory at ${tmpdirname} job ${jobid}"
		fi
		[[ -n "${no_rm}" ]] || rm -rf "${HYAKVNC_JOB_DIR}" && log DEBUG "Removed VNC directory ${HYAKVNC_JOB_DIR}"
	else
		log WARN "Job directory ${HYAKVNC_JOB_DIR} does not exist"
	fi

	if [[ -n "${should_cancel}" ]]; then
		log INFO "Cancelling job ${jobid}"
		sleep 1 # Wait for VNC process to exit
		scancel --full "${jobid}" || log ERROR "scancel failed to cancel job ${jobid}"
	fi
	return 0
}

# print_connection_info()
# Print connection instructions for a job, given job ID
# Arguments: -j | --jobid <jobid> (required) [ -p | --viewer-port <viewer_port> ] [ -n |--node <node> ] [ -s | --ssh-host <ssh_host> ]
#
# The generated connection string should look like this, depending on the the OS:
# ssh -f -L 6111:'/mmfs1/home/altan/.hyakvnc/jobs/14930429/socket.uds' -J altan@klone.hyak.uw.edu altan@g3071 sleep 10; vncviewer localhost:6111
function print_connection_info() {
	local jobid jobdir node socket_path viewer_port launch_hostname ssh_host
	viewer_port="${HYAKVNC_LOCALHOST_PORT:-5901}"
	ssh_host="${HYAKVNC_SSH_HOST:-klone.hyak.uw.edu}"
	# Parse arguments:
	while true; do
		case ${1:-} in
			-j | --jobid)
				shift
				jobid="${1:-}"
				shift
				;;
			-p | --viewer-port)
				shift
				viewer_port="${1:-viewer_port}"
				shift
				;;
			-n | --node)
				shift
				node="${1:-}"
				shift
				;;
			-s | --ssh-host)
				shift
				ssh_host="${1:-}"
				shift
				;;
			-*)
				log ERROR "Unknown option for print_connection_info: ${1:-}\n"
				return 1
				;;
			*)
				break
				;;
		esac
	done

	# Check arguments:
	[[ -z "${jobid}" ]] && {
		log ERROR "Job ID must be specified"
		return 1
	}
	[[ -z "${viewer_port}" ]] && {
		log ERROR "Viewer port must be specified"
		return 1
	}
	[[ -z "${ssh_host}" ]] && {
		log ERROR "SSH host must be specified"
		return 1
	}

	# Check that the job directory exists
	[[ -d "${jobdir:=${HYAKVNC_DIR}/jobs/${jobid}}" ]] || {
		log ERROR "Job directory ${HYAKVNC_JOB_DIR} does not exist"
		return 1
	}

	[[ -e "${socket_path:=${HYAKVNC_DIR}/jobs/${jobid}/vnc/socket.uds}" ]] || {
		log ERROR "Socket file ${socket_path} does not exist"
		return 1
	}
	[[ -S "${socket_path}" ]] || {
		log ERROR "Socket file ${socket_path} is not a socket"
		return 1
	}

	[[ -n "${node}" ]] || node=$(squeue -h -j "${jobid}" -o '%N' | grep -o -m 1 -E '\S+') || log DEBUG "Failed to get node for job ${jobid} from squeue"
	if [[ -r "${HYAKVNC_DIR}/jobs/${jobid}/vnc/hostname" ]] && launch_hostname=$(cat "${HYAKVNC_DIR}/jobs/${jobid}/vnc/hostname" 2>/dev/null || true) && [[ -n "${launch_hostname:-}" ]]; then
		[[ "${node}" = "${launch_hostname}" ]] || log WARN "Node for ${jobid} from hostname file (${HYAKVNC_DIR}/jobs/${jobid}/vnc/hostname) (${launch_hostname:-}) does not match node from squeue (${node}). Was the job restarted?"
		[[ -z "${node}" ]] && {
			log DEBUG "Node for ${jobid} from squeue is blank. Setting to ${launch_hostname}"
			node="${launch_hostname}"
		}
	else
		log WARN "Failed to get originally launched node for job ${jobid} from ${HYAKVNC_DIR}/jobs/${jobid}/hostname"
	fi

	[[ -z "${node}" ]] && {
		log ERROR "No node identified for job ${jobid}"
		return 1
	}

	local ssh_args
	ssh_args=()
	ssh_args+=("-o StrictHostKeyChecking=no")
	ssh_args+=("-L" "${viewer_port}:${socket_path}")
	ssh_args+=("-J" "${USER}@${HYAKVNC_SSH_HOST}")
	ssh_args+=("${USER}@${node}")

	# Print connection instruction header:

	cat <<EOF
==========
Copy and paste these instructions into a command line terminal on your local machine to connect to the VNC session.
You may need to install a VNC client if you don't already have one.

NOTE: If you receive an error that looks like "Permission denied (publickey,gssapi-keyex,gssapi-with-mic)", you don't have an SSH key set up. See https://hyak.uw.edu/docs/setup/intracluster-keys for more information. To set this up quickly on Linux, macOS, or Windows (WSL2/Cygwin), open a new terminal window on your machine and enter the following 2 commands before you try again:

[ ! -r ~/.ssh/id_rsa ] && ssh-keygen -t rsa -b 4096 -N '' -C "${USER}@uw.edu" -f ~/.ssh/id_rsa
ssh-copy-id -o StrictHostKeyChecking=no ${USER}@klone.hyak.uw.edu
---------
EOF
	# Print connection instructions for each operating system:
	echo "LINUX TERMINAL (bash/zsh):"
	echo "ssh -f ${ssh_args[*]} sleep 20 && vncviewer localhost:${viewer_port} || xdg-open vnc://localhost:${viewer_port} || echo 'No VNC viewer found. Please install one or try entering the connection information manually.'"
	echo

	echo "MACOS TERMINAL"
	printf "ssh -f %s sleep 20 && " "${ssh_args[*]}"
	# Print a command to open a VNC viewer for each bundle ID:
	for bundleid in ${HYAKVNC_MACOS_VNC_VIEWER_BUNDLEIDS}; do
		printf "open -b %s --args localhost:%s 2>/dev/null || " "${bundleid}" "${viewer_port}"
	done

	# Try default VNC viewer built into macOS:
	printf "open vnc://localhost:%s 2>/dev/null || " "${viewer_port}"

	# And finally, print a command to warn the user if no VNC viewer was found:
	printf "echo 'No VNC viewer found. Please install one or try entering the connection information manually.'\n"
	echo

	echo "WINDOWS"
	echo "ssh -f ${ssh_args[*]} sleep 20 && cmd.exe /c cmd /c \"\$(cmd.exe /c where \"C:\Program Files\TurboVNC;C:\Program Files (x86)\TurboVNC:vncviewerw.bat\")\" localhost:${viewer_port} || echo 'No VNC viewer found. Please install one or try entering the connection information manually.'"
	echo
	echo "=========="

}

# # Apptainer utility functions:

# # Commands

# ## Command: create

# help_create()
function help_create() {
	cat <<EOF
Create a VNC session on Hyak

Usage: hyakvnc create [create options...] -c <container> [extra args to pass to apptainer...]

Description:
	Create a VNC session on Hyak.

Options:
	-h, --help	Show this help message and exit
	-d, --debug	Enable debug logging
	-c, --container	Path to container image (required)

Apptainer options:
	--apptainer-args	Any arguments after this will be passed to apptainer.

SLURM options (available when running on SLURM login node):
	Any arguments after the above options will be passed to sbatch.
	See 'sbatch --help' for more information.

Examples:
	# Create a VNC session using the container ~/containers/mycontainer.sif
	hyakvnc create -c ~/containers/mycontainer.sif
	# Create a VNC session using the URL for a container:
	hyakvnc create -c oras://ghcr.io/maouw/hyakvnc_apptainer/hyakvnc-vncserver-ubuntu22.04:latest
	# Use the SLURM account escience, the partition gpu-a40, 4 CPUs, 1GB of memory, 1 GPU, and 1 hour of time:
	hyakvnc create -c ~/containers/mycontainer.sif -A escience -p gpu-a40 -C 4 -m 1G -t 1:00:00 -g 1
EOF
}

# cmd_create()
function cmd_create() {
	local apptainer_args=()
	local sbatch_args=()
	local container_basename container_name
	local instance_err_log
	# Parse arguments:
	while (($# > 0)); do
		case ${1:-} in
			--?*=* | -?*=*) # Handle --flag=value args
				set -- "${1%%=*}" "${1#*=}" "${@:2}"
				continue
				;;
			-h | --help)
				help_create
				return 0
				;;
			-c | --container)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				export HYAKVNC_APPTAINER_CONTAINER="${1:-}"
				;;
			--apptainer-args) # Args to pass to Apptainer
				shift
				while (($# > 0)); do
					[[ "${1:-}" == "--" ]] && break
					apptainer_args+=("${1:-}")
					shift
				done
				;;
			--)
				if [[ "${HYAKVNC_BACKEND:-}" == "slurm" ]]; then
					shift
					while (($# > 0)); do
						[[ "${1:-}" == "--" ]] && break
						sbatch_args+=("${1:-}")
						shift
					done
				fi
				;;
			*)
				break
				;;
		esac
		shift
	done

	

	[[ -z "${HYAKVNC_APPTAINER_CONTAINER}" ]] && { log ERROR "Container image must be specified"; return 1; }
	container_basename="$(basename "${HYAKVNC_APPTAINER_CONTAINER}")" || { log ERROR "Failed to get container basename from \"${HYAKVNC_APPTAINER_CONTAINER}\""; return 1; }
	[[ -z "${container_basename}" ]] && { log ERROR "The basename for the container \"${HYAKVNC_APPTAINER_CONTAINER}\"" is empty; return 1; }

	case "${HYAKVNC_APPTAINER_CONTAINER}" in
		library://* | docker://* | shub://* | oras://* | http://* | https://*)
			log TRACE "Container image \"${HYAKVNC_APPTAINER_CONTAINER}\" is a URL"

			# Add a tag if none is specified:
			[[ "${container_basename}" =~ .*:.* ]] || HYAKVNC_APPTAINER_CONTAINER="${HYAKVNC_APPTAINER_CONTAINER}:latest"

			;;

		*)
			[[ ! -f "${HYAKVNC_APPTAINER_CONTAINER:-}" ]] || [[ ! -r "${HYAKVNC_APPTAINER_CONTAINER:-}" ]] && { log ERROR "Cannot read Apptainer image at \"${HYAKVNC_APPTAINER_CONTAINER}\""; return 1; }
			;;
	esac

	[[ -z "${container_name:=${container_basename%\.@(sif|simg|img|sqsh)}}" ]] && { log ERROR "Failed to get container name from name \"${container_basename}\""; return 1; }

	apptainer_args+=("--bind" "${HOME}:/home-${USER}")

	# Set job name:
	export HYAKVNC_JOB_NAME="${HYAKVNC_JOB_NAME:-${HYAKVNC_JOB_PREFIX:-hyakvnc-}${container_name}}"

	# Export relevant variables:
	[[ -n "${!APPTAINER_@}" ]] && export "${!APPTAINER_@}"           # Export all SBATCH_ variables
	[[ -n "${!APPTAINERENV_@}" ]] && export "${!APPTAINERENV_@}"     # Export all SBATCH_ variables
	[[ -n "${!SINGULARITY_@}" ]] && export "${!SINGULARITY_@}"       # Export all SBATCH_ variables
	[[ -n "${!SINGULARITYENV_@}" ]] && export "${!SINGULARITYENV_@}" # Export all SBATCH_ variables
	[[ -n "${!HYAKVNC_@}" ]] && export "${!HYAKVNC_@}"               # Export all SBATCH_ variables

	# Backend-specific initialization:
	case "${HYAKVNC_BACKEND:-}" in
		apptainer)
			local timestr
			timestr=$(date '+%s') || { log ERROR "Failed to get date"; timestr=0; }
			HYAKVNC_JOB_DIR=$(mktemp --tmpdir="${HYAKVNC_JOBS_DIR}" --directory "${HYAKVNC_JOB_PREFIX}${timestr:-0}-XXX") || { log ERROR "Failed to create job directory"; return 1; }
			HYAKVNC_JOB_ID=$(basename "${HYAKVNC_JOB_DIR}")
			export HYAKVNC_JOB_DIR HYAKVNC_JOB_ID

			log DEBUG "Job directory: \"${HYAKVNC_JOB_DIR}\""

			mkdir -p "${HYAKVNC_JOB_DIR}/vnc" || { log ERROR "Failed to create job directory ${HYAKVNC_JOB_DIR}"; return 1; }

			apptainer_args+=("--bind" "${HYAKVNC_JOB_DIR}/vnc:/vnc")

			HYAKVNC_JOB_TMPDIR="$(mktemp -d --suffix "_hyakvnc_tmp_${HYAKVNC_JOB_ID}")" || { log ERROR "Failed to create temporary directory"; return 1; }
			apptainer_args+=("--bind" "${HYAKVNC_JOB_TMPDIR}:/tmp")
			apptainer_args+=("${HYAKVNC_APPTAINER_CONTAINER}")
			apptainer_args+=("${HYAKVNC_JOB_ID}")

			log DEBUG "Launching job with command: \"apptainer instance run ${apptainer_args[*]}\""

			# shellcheck disable=SC2016
			[[ -z "${XNOTRAP:-}" ]] && trap 'log WARN "Interrupted while running \"${BASH_COMMAND:-}\". Cleaning up and exiting!"; apptainer instance stop "${HYAKVNC_JOB_ID}" && [[ -n "${HYAKVNC_JOB_DIR:-}" ]] && [[ -d "${HYAKVNC_JOB_DIR}" ]] && rm -rf "${HYAKVNC_JOB_DIR}" && log INFO "Removed job directory ${HYAKVNC_JOB_DIR}"; trap - SIGINT SIGTSTP ERR EXIT; exit 1' SIGINT SIGTSTP ERR EXIT
			apptainer instance run "${apptainer_args[@]}" || { log ERROR "Failed to launch job"; return 1; }

			# Wait for job to start running by monitoring the output of squeue:
			log INFO "Waiting for job ${HYAKVNC_JOB_ID} (\"${HYAKVNC_JOB_NAME}\") to start"

			# Get the path to the instance log file:
			instance_err_log="$(apptainer instance list -l "${HYAKVNC_JOB_NAME}" | grep -m 1 -oE '\/.*\.err$' || true)"
			;;

		slurm)
			# Set sbatch arguments or environment variables
			export SBATCH_JOB_NAME="${HYAKVNC_JOB_NAME}"
			apptainer_args+=("--bind" "${HOME}:/home-${USER}")
			apptainer_args+=("--bind" "\"\${jobtmp}:/tmp\"") # jobtmp will be set by the sbatch script via mktemp()
			apptainer_args+=("--bind" "${HYAKVNC_JOBS_DIR}/\${SLURM_JOB_ID}/vnc:/vnc")

			if [[ "${SBATCH_CLUSTERS:-}" == "klone" ]]; then
				[[ -d "/mmfs1" ]] && apptainer_args+=("--bind" "/mmfs1")
				[[ -d "/gscratch" ]] && apptainer_args+=("--bind" "/gscratch")
				[[ -d "/data" ]] && apptainer_args+=("--bind" "/data")
			fi

			[[ -n "${SBATCH_GPUS:-}" ]] && export APPTAINER_NV=1

			# Set sbatch exported environment variables
			if [[ -z "${SBATCH_EXPORT:-}" ]]; then
				local -a sbatch_export_additions=()
				[[ -n "${SRUN_CPUS_PER_TASK:-}" ]] && sbatch_export_additions+=("${SRUN_CPUS_PER_TASK}")
				[[ -n "${!APPTAINER_@}" ]] && sbatch_export_additions+=("${!APPTAINER_@}")
				[[ -n "${!APPTAINERENV_@}" ]] && sbatch_export_additions+=("${!APPTAINERENV_@}")
				[[ -n "${!SINGULARITY_@}" ]] && sbatch_export_additions+=("${!SINGULARITY_@}")
				[[ -n "${!SINGULARITYENV_@}" ]] && sbatch_export_additions+=("${!SINGULARITYENV_@}")
				[[ -n "${!HYAKVNC_@}" ]] && sbatch_export_additions+=("${!HYAKVNC_@}")
				sbatch_export_additions+=("NONE")
				SBATCH_EXPORT="${sbatch_export_additions[*]}" # Set SBATCH_EXPORT to the union of SRUN_CPUS_PER_TASK and APPTAINER_ and APPTAINERENV_ and SINGULARITY_ and SINGULARITYENV_ and HYAKVNC_ variables, plus the --export=NONE option
				SBATCH_EXPORT="${SBATCH_EXPORT// /,}"         # Replace spaces with commas
				export SBATCH_EXPORT
			fi

			apptainer_args+=("${HYAKVNC_APPTAINER_CONTAINER}")

			# Append desired arguments to the sbatch command:
			sbatch_args+=(--wrap)

			sbatch_args+=(
				"mkdir -p \"${HYAKVNC_JOBS_DIR}/\${SLURM_JOB_ID}/vnc\" && jobtmp=\"\$(mktemp -d --suffix _hyakvnc_tmp_\${SLURM_JOB_ID})\" && echo \"\${jobtmp}\" > \"${HYAKVNC_JOBS_DIR}/\${SLURM_JOB_ID}/tmpdirname\" && apptainer run ${apptainer__args[*]}"
			)

			log DEBUG "Launching job with command: sbatch ${sbatch_args[*]}"

			sbatch_result=$(sbatch "${sbatch_args[@]}") || { log ERROR "Failed to launch job"; return 1; }

			# Quit if no job ID was returned:
			[[ -z "${sbatch_result:-}" ]] && { log ERROR "Failed to launch job - no result from sbatch" && return 1; }

			# Parse job ID and cluster from sbatch result (semicolon separated):
			export HYAKVNC_JOB_ID="${sbatch_result%%;*}}"
			[[ -z "${HYAKVNC_JOB_ID:-}" ]] && { log ERROR "Failed to parse job ID for newly launched job"; return 1; }

			export HYAKVNC_JOB_DIR="${HYAKVNC_JOBS_DIR}/${HYAKVNC_JOB_ID}"

			log DEBUG "Job directory: \"${HYAKVNC_JOB_DIR}\""

			# Wait for sbatch job to start running by monitoring the output of squeue:
			log INFO "Waiting for job ${HYAKVNC_JOB_ID} (\"${HYAKVNC_JOB_NAME}\") to start"

			# shellcheck disable=SC2016
			[[ -z "${XNOTRAP:-}" ]] && 'log WARN "Interrupted while running \"${BASH_COMMAND:-}\". Cleaning up and exiting!"; scancel --quiet "${HYAKVNC_JOB_ID}" && [[ -n "${HYAKVNC_JOB_DIR:-}" ]] && [[ -d "${HYAKVNC_JOB_DIR}" ]] && rm -rf "${HYAKVNC_JOB_DIR}" && log INFO "Removed job directory ${HYAKVNC_JOB_DIR}"; trap - SIGINT SIGTSTP ERR EXIT; return 1' SIGINT SIGTSTP ERR EXIT

			local starttime="${SECONDS:-0}"
			while true; do
				if ((SECONDS - starttime > HYAKVNC_SLURM_SUBMIT_TIMEOUT)); then
					log ERROR "Timed out waiting for job ${HYAKVNC_JOB_ID} to start"
					return 1
				fi
				sleep 1
				local squeue_result
				squeue_result=$(squeue --job "${HYAKVNC_JOB_ID}" --format "%T" --noheader || true)
				case "${squeue_result:-}" in
					SIGNALING | PENDING | CONFIGURING | STAGE_OUT | SUSPENDED | REQUEUE_HOLD | REQUEUE_FED | RESV_DEL_HOLD | STOPPED | RESIZING | REQUEUED)
						log TRACE "Job ${HYAKVNC_JOB_ID} is in a state that could potentially run: ${squeue_result}"
						sleep 1
						continue
						;;
					RUNNING)
						log DEBUG "Job ${HYAKVNC_JOB_ID} is \"${squeue_result}\""
						break
						;;
					*)
						log ERROR "Job ${HYAKVNC_JOB_ID} is in unexpected state \"${squeue_result}\""
						return 1
						;;
				esac
			done

			# Wait for job to create its directory:
			log TRACE "Waiting for job ${HYAKVNC_JOB_ID} to create its directory at ${HYAKVNC_JOB_DIR}"
			starttime="${SECONDS:-0}"
			while true; do
				if ((SECONDS - starttime > HYAKVNC_DEFAULT_TIMEOUT)); then
					log ERROR "Timed out waiting for job to create its directory at ${HYAKVNC_JOB_DIR}"
					return 1
				fi
				sleep 1
				[[ ! -d "${HYAKVNC_JOB_DIR}" ]] && {
					log TRACE "Job directory does not exist yet"
					continue
				}
				break
			done

			# Link the SLURM log file to the job directory:
			instance_err_log="${HYAKVNC_SLURM_OUTPUT_DIR}/${HYAKVNC_JOB_ID}.out"
			;;
		*) log ERROR "Unsupported \$HYAKVNC_BACKEND backend \"${HYAKVNC_BACKEND}\""; return 1 ;;
	esac

	if [[ -n "${instance_err_log:-}" ]] && [[ -r "${instance_err_log}" ]]; then
		HYAKVNC_JOB_ERR_LOG="${HYAKVNC_JOB_DIR}/job.log"
		ln -s "${instance_err_log}" "${HYAKVNC_JOB_ERR_LOG}" || { log WARN "Could not link \"${instance_err_log}\" to \"${HYAKVNC_JOB_DIR}/err.log\""; unset HYAKVNC_JOB_ERR_LOG; }
	else
		log WARN "Could not find instance log file"
	fi

	if [[ -n "${HYAKVNC_JOB_ERR_LOG:-}" ]] && [[ -f "${HYAKVNC_JOB_ERR_LOG}" ]] && [[ -r "${HYAKVNC_JOB_ERR_LOG}" ]] && check_log_level "${HYAKVNC_LOG_LEVEL}" DEBUG; then
		log INFO "Streaming log from \"${HYAKVNC_JOB_ERR_LOG}\""
		tail -n 1 -f "${HYAKVNC_JOB_ERR_LOG}" --pid=$$ 2>/dev/null | sed --unbuffered "s/^/${HYAKVNC_JOB_ID}: /" & # Follow the log file in the background
		tailpid=$!
		trap 'trap - EXIT; kill -9 "${tailpid}" 2>/dev/null' EXIT
	fi

	log INFO "Waiting for VNC server to start..."

	# Wait for socket to become available:
	log DEBUG "Waiting for job to create its socket file at ${HYAKVNC_JOB_DIR}/vnc/socket.uds"

	local starttime="${SECONDS:-0}"
	while true; do
		if ((SECONDS - starttime > HYAKVNC_DEFAULT_TIMEOUT)); then
			log ERROR "Timed out waiting for job to open its directories"
			return 1
		fi
		sleep 1
		[[ ! -d "${HYAKVNC_JOB_DIR}" ]] && log TRACE "Job directory does not exist yet" && continue
		[[ ! -e "${HYAKVNC_JOB_DIR}/vnc/socket.uds" ]] && log TRACE "Job socket does not exist yet" && continue
		[[ ! -S "${HYAKVNC_JOB_DIR}/vnc/socket.uds" ]] && log TRACE "Job socket is not a socket" && continue
		[[ ! -r "${HYAKVNC_JOB_DIR}/vnc/vnc.log" ]] && log TRACE "VNC log file not readable yet" && continue
		break
	done

	# Wait for VNC server to start by monitoring the VNC log file:
	grep -q '^xstartup.turbovnc: Executing' <(timeout "${HYAKVNC_DEFAULT_TIMEOUT}" tail -f "${HYAKVNC_JOB_DIR}/vnc/vnc.log" || true)

	log INFO "VNC server started"
	# Stop trapping the signals:
	[[ -z "${XNOTRAP:-}" ]] && trap - SIGINT SIGTERM SIGHUP SIGABRT SIGQUIT ERR EXIT
	return 0
}

# ## COMMAND: status

# help_status()
function help_status() {
	cat <<EOF
Show the status of running HyakVNC sessions

Usage: hyakvnc status [status options...]

Description:
	Check status of VNC session(s) on Hyak.

Options:
	-h, --help	Show this help message and exit

Examples:
	# Check the status of all VNC jobs:
	hyakvnc status
EOF
}

# cmd_status()
function cmd_status() {
	local running_jobid running_jobids headerstr rowsstr=''
	while true; do
		case ${1:-} in
			-h | --help)
				help_status
				return 0
				;;
			-j | --jobid) # Job ID to attach to (optional)
				shift
				running_jobid="${1:-}"
				shift
				;;
			-*)
				log ERROR "Unknown option: ${1:-}\n"
				exit 1
				;;
			*)
				break
				;;
		esac
	done

	headerstr="ID\tCreated\tState\tName"

	case "${HYAKVNC_BACKEND:-apptainer}" in
		apptainer)
			local adds s
			s="$(apptainer instance list "${HYAKVNC_JOB_PREFIX:-}"'*' || true)"
			[[ -z "${s:-}" ]] && { log INFO "Found no running jobs with names that match the prefix \"${HYAKVNC_JOB_PREFIX}\""; return 0; }
			local -i i=0
			while IFS= read -r; do
				local pid created state name id rest relative_created
				((i++ > 0)) || continue
				read -r name pid rest <<<"${REPLY}" || return 1
				created="$(date --date "$(ps -p "${pid}" -o lstart= || true)" -Is)" || return 1
				state="$(ps -p "${pid}" -o state=)" || return 1
				relative_created="$(relativize_date "${created}")" || return 1

				id="${pid}--${name}"
				printf -v adds "%s\t%s\t%s\t%s\n" "${id}" "${relative_created}" "${state}" "${name}"
				rowsstr+="${adds}"
			done <<<"${s}"
			;;

		slurm)

			# Loop over directories in ${HYAKVNC_DIR}/jobs
			squeue_args=(--me --states=RUNNING --noheader --format '%j %i')
			[[ -n "${running_jobid:-}" ]] && squeue_args+=(--job "${running_jobid}")
			running_jobids=$(squeue "${squeue_args[@]}" | grep -E "^${HYAKVNC_JOB_PREFIX}" | grep -oE '[0-9]+$') || {
				log WARN "Found no running job IDs with names that match the set job name prefix ${HYAKVNC_JOB_PREFIX}"
				return 1
			}
			[[ -z "${running_jobids:-}" ]] && {
				log INFO "Found no running job IDs with names that match the prefix ${HYAKVNC_JOB_PREFIX}"
				return 0
			}

			for running_jobid in ${running_jobids:-}; do
				local running_job_node jobdir
				running_job_node=$(squeue --job "${running_jobid}" --format "%N" --noheader --states=RUNNING) || {
					log WARN "Failed to get node for job ${running_jobid}"
					continue
				}
				[[ -z "${running_job_node}" ]] && {
					log WARN "Failed to get node for job ${running_jobid}"
					continue
				}
				jobdir="${HYAKVNC_DIR}/jobs/${running_jobid}"
				[[ ! -d "${HYAKVNC_JOB_DIR}" ]] && {
					log WARN "Job directory ${HYAKVNC_JOB_DIR} does not exist"
					continue
				}
				[[ ! -e "${HYAKVNC_JOB_DIR}/vnc/socket.uds" ]] && {
					log WARN "Job socket not found at ${HYAKVNC_JOB_DIR}/vnc/socket.uds"
					continue
				}
				[[ ! -S "${HYAKVNC_JOB_DIR}/vnc/socket.uds" ]] && {
					log WARN "Job socket at ${HYAKVNC_JOB_DIR}/vnc/socket.uds is not a socket"
					continue
				}
				echo "HyakVNC job ${running_jobid} is running on node ${running_job_node}"
			done
			;;
		*) log ERROR "Unsupported \$HYAKVNC_BACKEND backend \"${HYAKVNC_BACKEND}\""; return 1 ;;
	esac
	
	[[ -z "${rowsstr:-}" ]] && {
		log INFO "Found no running jobs with names that match the prefix \"${HYAKVNC_JOB_PREFIX}\""
		return 0
	}
	printf '%b\n%b' "${headerstr:-}" "${rowsstr:-}" | column -t -s $'\t'

}

# ## COMMAND: stop

# help_stop()
function help_stop() {
	cat <<EOF
Stop a HyakVNC session

Usage: hyakvnc stop [-a] [<jobids>...]
	
Description:
	Stop a provided HyakVNC sesssion and clean up its job directory.
	If no job ID is provided, a menu will be shown to select from running jobs.

Options:
	-h, --help	Show this help message and exit
	-n, --no-cancel	Don't cancel the SLURM job
	-a, --all	Stop all jobs

Examples:
	# Stop a VNC session running on job 123456:
	hyakvnc stop 123456
	# Stop a VNC session running on job 123456 and do not cancel the job:
	hyakvnc stop --no-cancel 123456
	# Stop all VNC sessions:
	hyakvnc stop -a
	# Stop all VNC sessions but do not cancel the jobs:
	hyakvnc stop -a -n
EOF
}

# cmd_stop()
function cmd_stop() {
	local jobids all jobid nocancel stop_hyakvnc_session_args
	should_cancel=1
	stop_hyakvnc_session_args=()
	# Parse arguments:
	while true; do
		case ${1:-} in
			-h | --help)
				help_stop
				return 0
				;;
			-a | --all)
				shift
				all=1
				;;
			-n | --no-cancel)
				shift
				nocancel=1
				;;
			-*)
				log ERROR "Unknown option for stop: ${1:-}\n"
				return 1
				;;
			*)
				jobids="${*:-}"
				break
				;;
		esac
	done
	if [[ -z "${nocancel:-}" ]]; then
		stop_hyakvnc_session_args+=("--cancel")
	fi

	case "${HYAKVNC_BACKEND:-apptainer}" in
		apptainer) ;;

		slurm)

			if [[ -n "${all}" ]]; then
				jobids=$(squeue --me --format '%j %i' --noheader | grep -E "^${HYAKVNC_JOB_PREFIX}" | grep -oE '[0-9]+$') || log WARN "Found no running job IDs with names that match the prefix ${HYAKVNC_JOB_PREFIX}"
			fi

			if [[ -z "${jobids}" ]]; then
				if [[ -t 1 ]]; then
					echo "Reading available job IDs to select from a menu"
					running_jobids=$(squeue --me --noheader --format '%j %i' | grep -E "^${HYAKVNC_JOB_PREFIX}" | grep -oE '[0-9]+$') || {
						log WARN "Found no running jobs  with names that match the prefix ${HYAKVNC_JOB_PREFIX}"
						return 1
					}
					PS3="Enter a number: "
					select jobids in ${running_jobids}; do
						echo "Selected job: ${jobids}" && echo && break
					done
				fi
			fi

			[[ -z "${jobids}" ]] && {
				log ERROR "Must specify running job IDs"
				exit 1
			}

			# Cancel any jobs that were launched:
			for jobid in ${jobids}; do
				stop_hyakvnc_session "${stop_hyakvnc_session_args[@]}" "${jobid}" && log INFO "Stopped job ${jobid}"
			done
			;;

		*) log ERROR "Unsupported \$HYAKVNC_BACKEND backend \"${HYAKVNC_BACKEND}\""; return 1 ;;
	esac

	return 0
}

# ## COMMAND: show

# help_show()
function help_show() {
	cat <<EOF
Show connection information for a HyakVNC sesssion

Usage: hyakvnc show <jobid>
	
Description:
	Show connection information for a HyakVNC sesssion. 
	If no job ID is provided, a menu will be shown to select from running jobs.
	
Options:
	-h, --help	Show this help message and exit

Examples:
	# Show connection information for session running on job 123456:
	hyakvnc show 123456
	# Interactively select a job to show connection information for:
	hyakvnc show

	# Show connection information for session running on job 123456 for macOS:
	hyakvnc show -s mac 123456
EOF
}

# cmd_show()
function cmd_show() {
	local jobid running_jobids
	# Parse arguments:
	while true; do
		case "${1:-}" in
			-h | --help)
				help_show
				return 0
				;;
			-d | --debug) # Debug mode
				shift
				export HYAKVNC_LOG_LEVEL=DEBUG
				;;
			-*)
				log ERROR "Unknown option for show: ${1:-}\n"
				return 1
				;;
			*)
				jobid="${1:-}"
				break
				;;
		esac
	done

	if [[ -z "${jobid:-}" ]]; then
		if [[ -t 1 ]]; then
			echo "Reading available job IDs to select from a menu"
			running_jobids=$(squeue --me --noheader --format '%j %i' --states RUNNING | grep -E "^${HYAKVNC_JOB_PREFIX}" | grep -oE '[0-9]+$') || {
				log WARN "Found no running jobs with names that match the prefix ${HYAKVNC_JOB_PREFIX}"
				return 1
			}
			PS3="Enter a number: "
			select jobid in ${running_jobids}; do
				echo "Selected job: ${jobid}" && echo && break
			done
		fi
	fi
	[[ -z "${jobid}" ]] && {
		log ERROR "Must specify running job IDs"
		return 1
	}
	running_jobids=$(squeue --me --job "${jobid}" --noheader --format '%j %i' | grep -E "^${HYAKVNC_JOB_PREFIX}" | grep -oE '[0-9]+$') || {
		log WARN "Found no running job for job ${jobid} with names that match the prefix ${HYAKVNC_JOB_PREFIX}"
		return 1
	}
	print_connection_info -j "${jobid}" || {
		log ERROR "Failed to print connection info for job ${jobid}"
		return 1
	}
	return 0
}

# ## COMMAND: update

# help_update()
function help_update() {
	cat <<EOF
Update hyakvnc

Usage: hyakvnc update [update options...]
	
Description:
	Update hyakvnc.

Options:
	-h, --help			Show this help message and exit

Examples:
	# Update hyakvnc
	hyakvnc update
EOF
}

# cmd_update()
function cmd_update() {
	log INFO "Checking for updates..."
	if ! hyakvnc_check_updates; then
		log INFO "No updates to apply."
	else
		log INFO "Applying updates..."
		if ! hyakvnc_pull_updates; then
			log WARN "No updates applied."
			exit 1
		else
			log INFO "Update complete."
		fi
	fi
}

# ## COMMAND: config

# help_config()
function help_config() {
	cat <<EOF
Show the current configuration for hyakvnc

Usage: hyakvnc config [config options...]
	
Description:
	Show the current configuration for hyakvnc, as set in the user configuration file at ${HYAKVNC_CONFIG_FILE}, in the current environment, or the default values set by hyakvnc.

Options:
	-h, --help		Show this help message and exit

Examples:
	# Show configuration
	hyakvnc config
EOF
}

# cmd_config()
function cmd_config() {
	# Parse arguments:
	while true; do
		case "${1:-}" in
			-h | --help)
				help_config
				return 0
				;;
			-*)
				help log ERROR "Unknown option for config: ${1:-}\n"
				return 1
				;;
			*)
				break
				;;
		esac
	done
	export -p | sed -E 's/^declare\s+-x\s+//; /^HYAKVNC_/!d'
	return 0
}

# ## COMMAND: help

# help_help()
function cmd_help() {
	local action_to_help
	local isinstalled
	isinstalled=$(command -v hyakvnc || echo '')
	[[ -n "${isinstalled:-}" ]] && isinstalled=" (is already installed!)"

	if [[ "${1:-help}" == "help" ]]; then
		cat <<EOF
hyakvnc -- A tool for launching VNC sessions on Hyak.
Usage: hyakvnc [hyakvnc options] [create|status|stop|show|config|update|help] [command options] [args...]

Description:
	Stop a provided HyakVNC sesssion and clean up its job directory

Options:
	-h, --help		Show this help message and exit
	-d, --debug		Print debugging information
	-V, --version	Print version information and exit

Available commands:
	create	Create a new VNC session
	status	Check status of VNC session(s)
	stop	Stop a VNC session
	show	Show connection information for a VNC session
	config	Show current configuration for hyakvnc
	update	Update hyakvnc
	help	Show help for a command

See 'hyakvnc help <command>' for more information on a specific command.

EOF
		return 0
	fi

	action_to_help=$(compgen -A function help_ | grep --max-count=1 "^help_${1:-}\$" || true)
	[[ -z "${action_to_help:-}" ]] && {
		log ERROR "help: Unknown command: ${1:-}"
		echo
		cmd_help
		exit 1
	}
	shift
	${action_to_help} "$@"
}

# Main

# main()
function main() {
	local action="cmd_help"
	local orig_args=()
	orig_args+=("${@:-}")

	[[ $# -eq 0 ]] && cmd_help && exit 0 # Show help if no arguments are provided
	while true; do
		case "${1:-}" in
			--?*=* | -?*=*) # Handle --flag=value args
				set -- "${1%%=*}" "${1#*=}" "${@:2}"
				continue
				;;
			-d | --debug) # Debug mode
				export HYAKVNC_LOG_LEVEL=DEBUG
				shift
				;;
			--log-level)
				shift || { log ERROR "$1 requires an argument"; return 1; }
				export HYAKVNC_LOG_LEVEL="$1"
				if check_log_level "${HYAKVNC_LOG_LEVEL}" "${HYAKVNC_LOG_FILE_LEVEL:-INFO}"; then
					export HYAKVNC_LOG_FILE_LEVEL="${HYAKVNC_LOG_LEVEL}"
				fi
				shift
				;;
			-h | --help)
				shift
				cmd_help "${@:-}"
				return 0
				;;
			-V | --version)
				echo "HyakVNC version ${HYAKVNC_VERSION}"
				return 0
				;;
			*)
				action=$(compgen -A function cmd_ | grep --max-count=1 "^cmd_${1:-}\$" || true)
				[[ -z "${action:-}" ]] && {
					log ERROR "Unknown command: ${1:-}"
					cmd_help
					return 1
				}
				shift
				break
				;;
		esac
	done

	case "${action}" in
		cmd_help | cmd_install | cmd_update | cmd_config)
			if check_slurm_running; then
				hyakvnc_config_init || log WARN "Could't initialize config automatically" # Don't exit if config can't be initialized (e.g., not running on SLURM)
			fi
			;;
		*)
			hyakvnc_config_init || exit 1                                        # Fill in default values for config variables or exit if config can't be initialized
			hyakvnc_autoupdate "${orig_args:-}" || log TRACE "Didn't autoupdate" # Don't exit if didn't autoupdate
			;;
	esac
	${action} "$@"
}

# Invoke main with args if not sourced:
if ! (return 0 2>/dev/null); then
	main "$@"
fi
